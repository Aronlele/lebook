# 线程安全

## 概念
- 当多个线程访问某个类时，不管运行环境采用何种调度方式，或者这些线程如何调度执行，并且在主调代码中不需要任何的额外同步或协同，这个类都表现中正确的行为，那么这个类就是线程安全的

## 线程安全性

- 原子性

  提供了互斥访问，同一时刻只有一个线程可以对资源进行操作
  
- 有序性
  
  一个线程观察其他线程执行顺序，由于指令重排序，一般是杂乱的
  
- 可见性

  一个线程对资源的操作，可以被其他线程观察到
  
## 原子性 Atomic包

- AtomicXXX: CAS、unsafe.compareAndSwapInt
- AtomicLong LongAdder
- AtomicReference AtomicReferenceFieldUpdater
- AtomicStampReference CAS的ABA问题

  ABA问题：CAS操作改变线程 A->B ->A 导致无法统计改变，不符合设计规则，解决方案，添加版本号

## 原子性 锁synchronized 依赖JVM

- 修饰代码块 大括号包括起来的代码，作用于调用的对象
- 修饰方法 整个方法，作用于调用的对象
- 修饰静态方法 整个静态方法，作用于所有对象
- 修饰类 括号包括起来的代码

## 原子性 Lock 依赖特殊的CPU指令，按序执行

    java.util.concurrent.locks.ReentrantLock
    
```
一个可重入互斥Lock具有与使用synchronized方法和语句访问的隐式监视锁相同的基本行为和语义，但具有扩展功能。
A ReentrantLock由线程拥有 ，最后成功锁定，但尚未解锁。
```

## 可见性

导致共享变量，在线程间不可见得原因为：

1. 线程交叉执行
2. 重排序结合线程交叉执行
3. 共享变量更新后的值没有在主存、工作内存中及时更新

## 可见性 volatile

通过加入内存屏障 和禁止重排序优化来实现

1. 对volatile变量进行读操作时，操作前加一条load屏障指令，从主内存中读取变量
2. 对volatile变量进行写操作时，操作前加一条store屏障指令，将本地内存变量缓存到

